const express = require('express');
const path = require('path');
const cors = require('cors');
const compression = require('compression');
const helmet = require('helmet');
const { Kernel } = require('./core/kernel.js');
const { StorageAPI } = require('./apis/storage-apis.js');

class RSSServer {
    constructor() {
        this.app = express();
        this.port = process.env.PORT || 3000;
        this.kernel = null;
        this.storageAPI = null;
        
        this.setupMiddleware();
        this.setupRoutes();
        this.setupErrorHandling();
    }

    setupMiddleware() {
        // å®‰å…¨ä¸­é—´ä»¶
        this.app.use(helmet({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    styleSrc: ["'self'", "'unsafe-inline'", "https://cdnjs.cloudflare.com"],
                    scriptSrc: ["'self'", "'unsafe-inline'"],
                    fontSrc: ["'self'", "https://cdnjs.cloudflare.com"],
                    imgSrc: ["'self'", "data:", "https:"],
                    connectSrc: ["'self'"]
                }
            }
        }));
        
        // å‹ç¼©ä¸­é—´ä»¶
        this.app.use(compression());
        
        // CORSä¸­é—´ä»¶
        this.app.use(cors({
            origin: process.env.CORS_ORIGIN || '*',
            credentials: true
        }));
        
        // è§£æä¸­é—´ä»¶
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));
        
        // é™æ€æ–‡ä»¶æœåŠ¡
        this.app.use('/static', express.static(path.join(__dirname, 'modules/ui/layout')));
        this.app.use('/static', express.static(path.join(__dirname, 'public')));
    }

    setupRoutes() {
        // APIè·¯ç”±å‰ç¼€
        const apiRouter = express.Router();
        
        // RSSæºç®¡ç†
        apiRouter.get('/feeds', this.getFeeds.bind(this));
        apiRouter.post('/feeds', this.addFeed.bind(this));
        apiRouter.put('/feeds/:id', this.updateFeed.bind(this));
        apiRouter.delete('/feeds/:id', this.deleteFeed.bind(this));
        
        // æ–‡ç« ç®¡ç†
        apiRouter.get('/articles', this.getArticles.bind(this));
        apiRouter.get('/articles/:id', this.getArticle.bind(this));
        apiRouter.put('/articles/:id/read', this.markArticleRead.bind(this));
        apiRouter.put('/articles/:id/star', this.toggleArticleStar.bind(this));
        
        // åˆ†ç±»ç®¡ç†
        apiRouter.get('/categories', this.getCategories.bind(this));
        apiRouter.post('/categories', this.addCategory.bind(this));
        
        // æœç´¢
        apiRouter.get('/search', this.searchArticles.bind(this));
        
        // ç»Ÿè®¡ä¿¡æ¯
        apiRouter.get('/stats', this.getStats.bind(this));
        
        // æŒ‚è½½APIè·¯ç”±
        this.app.use('/api', apiRouter);
        
        // ä¸»é¡µè·¯ç”±
        this.app.get('/', (req, res) => {
            res.sendFile(path.join(__dirname, 'modules/ui/layout/index.html'));
        });
        
        // å¥åº·æ£€æŸ¥
        this.app.get('/health', (req, res) => {
            res.json({ status: 'ok', timestamp: new Date().toISOString() });
        });
    }

    async initialize() {
        try {
            // åˆå§‹åŒ–å†…æ ¸
            this.kernel = new Kernel();
            await this.kernel.init();
            
            // è·å–å­˜å‚¨API
            this.storageAPI = await this.kernel.getService('storage');
            
            console.log('RSSæœåŠ¡å™¨åˆå§‹åŒ–å®Œæˆ');
        } catch (error) {
            console.error('æœåŠ¡å™¨åˆå§‹åŒ–å¤±è´¥:', error);
            throw error;
        }
    }

    // APIå¤„ç†å™¨
    async getFeeds(req, res) {
        try {
            const feeds = await this.storageAPI.getAllFeeds();
            res.json({ success: true, data: feeds });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async addFeed(req, res) {
        try {
            const { url, category, name } = req.body;
            
            if (!url) {
                return res.status(400).json({ success: false, error: 'RSS URL is required' });
            }
            
            const feedId = await this.storageAPI.addFeed(url, category, name);
            res.json({ success: true, data: { id: feedId } });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async updateFeed(req, res) {
        try {
            const { id } = req.params;
            const updates = req.body;
            
            await this.storageAPI.updateFeed(parseInt(id), updates);
            res.json({ success: true });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async deleteFeed(req, res) {
        try {
            const { id } = req.params;
            await this.storageAPI.removeFeed(parseInt(id));
            res.json({ success: true });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async getArticles(req, res) {
        try {
            const { feedId, category, unread, starred, limit = 50, offset = 0 } = req.query;
            
            let articles;
            
            if (feedId) {
                articles = await this.storageAPI.getArticlesByFeed(parseInt(feedId));
            } else if (category) {
                articles = await this.storageAPI.getArticlesByCategory(category);
            } else if (unread === 'true') {
                articles = await this.storageAPI.getUnreadArticles();
            } else if (starred === 'true') {
                articles = await this.storageAPI.getStarredArticles();
            } else {
                articles = await this.storageAPI.getAllArticles(parseInt(limit), parseInt(offset));
            }
            
            res.json({ success: true, data: articles });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async getArticle(req, res) {
        try {
            const { id } = req.params;
            const article = await this.storageAPI.getArticle(parseInt(id));
            
            if (!article) {
                return res.status(404).json({ success: false, error: 'Article not found' });
            }
            
            res.json({ success: true, data: article });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async markArticleRead(req, res) {
        try {
            const { id } = req.params;
            await this.storageAPI.markArticleAsRead(parseInt(id));
            res.json({ success: true });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async toggleArticleStar(req, res) {
        try {
            const { id } = req.params;
            const { starred } = req.body;
            
            await this.storageAPI.toggleArticleStar(parseInt(id), starred);
            res.json({ success: true });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async getCategories(req, res) {
        try {
            const categories = await this.storageAPI.getAllCategories();
            res.json({ success: true, data: categories });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async addCategory(req, res) {
        try {
            const { name } = req.body;
            
            if (!name) {
                return res.status(400).json({ success: false, error: 'Category name is required' });
            }
            
            const categoryId = await this.storageAPI.addCategory(name);
            res.json({ success: true, data: { id: categoryId } });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async searchArticles(req, res) {
        try {
            const { q, limit = 20 } = req.query;
            
            if (!q) {
                return res.status(400).json({ success: false, error: 'Search query is required' });
            }
            
            const results = await this.storageAPI.searchArticles(q, parseInt(limit));
            res.json({ success: true, data: results });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    async getStats(req, res) {
        try {
            const stats = await this.storageAPI.getStatistics();
            res.json({ success: true, data: stats });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    }

    setupErrorHandling() {
        // 404å¤„ç†
        this.app.use((req, res) => {
            res.status(404).json({ success: false, error: 'Endpoint not found' });
        });
        
        // é”™è¯¯å¤„ç†ä¸­é—´ä»¶
        this.app.use((error, req, res, next) => {
            console.error('æœåŠ¡å™¨é”™è¯¯:', error);
            res.status(500).json({
                success: false,
                error: process.env.NODE_ENV === 'production' ? 'Internal server error' : error.message
            });
        });
    }

    async start() {
        try {
            await this.initialize();
            
            this.app.listen(this.port, () => {
                console.log(`ğŸš€ RSSæœåŠ¡å™¨è¿è¡Œåœ¨ http://localhost:${this.port}`);
                console.log(`ğŸ“± æ‰“å¼€æµè§ˆå™¨è®¿é—® http://localhost:${this.port} å¼€å§‹ä½¿ç”¨`);
                console.log(`ğŸ”§ APIæ–‡æ¡£: http://localhost:${this.port}/api`);
            });
        } catch (error) {
            console.error('å¯åŠ¨æœåŠ¡å™¨å¤±è´¥:', error);
            process.exit(1);
        }
    }
}

// å¦‚æœæ˜¯ç›´æ¥è¿è¡Œæ­¤æ–‡ä»¶
if (require.main === module) {
    const server = new RSSServer();
    server.start();
}

module.exports = { RSSServer };